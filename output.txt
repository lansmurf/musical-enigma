./CoinModProject.csproj
---
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <AssemblyName>lansmurf.PeakCoinMod</AssemblyName>
    <Description>Adds a coin and shopkeeper system to PEAK.</Description>
    <Version>1.2.0</Version>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BepInEx.AssemblyPublicizer" Version="0.5.0-beta.1" PrivateAssets="all" />
    <PackageReference Include="BepInEx.BaseLib" Version="5.*" />
    <PackageReference Include="BepInEx.Analyzers" Version="1.*" PrivateAssets="all" />
    <PackageReference Include="BepInEx.PluginInfoProps" Version="1.*" />
    <PackageReference Include="HarmonyX" Version="2.10.2" />
    
    <Reference Include="UnityEngine" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.InputLegacyModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <!-- === REQUIRED UNITY MODULES === -->
    <Reference Include="UnityEngine.PhysicsModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.AnimationModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.AnimationModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.IMGUIModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <!-- THIS IS THE NEW REFERENCE YOU NEED -->
    <Reference Include="UnityEngine.UIModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.UIModule.dll</HintPath>
        <Private>false</Private>
    </Reference>

    <Reference Include="UnityEngine.UI" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.UI.dll</HintPath>
        <Private>false</Private>
    </Reference>

    <Reference Include="Unity.TextMeshPro" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Unity.TextMeshPro.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <Reference Include="Sirenix.Serialization" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Sirenix.Serialization.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <!-- === END OF REQUIRED MODULES === -->

    <Reference Include="Assembly-CSharp" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Assembly-CSharp.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="Zorro.Core.Runtime" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Zorro.Core.Runtime.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="PhotonUnityNetworking" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\PhotonUnityNetworking.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="PhotonRealtime" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\PhotonRealtime.dll</HintPath>
        <Private>false</Private>
    </Reference>
  </ItemGroup>
</Project>

---
./CoinPlugin.cs
---
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;

namespace CoinMod
{
    [BepInPlugin("com.yourusername.peakcoinmod", "Peak Coin Mod", "3.0.0")]
    public class CoinPlugin : BaseUnityPlugin
    {
        internal static ManualLogSource Log;

        private void Awake()
        {
            Log = Logger;
            Log.LogInfo("Peak Coin Mod v3.0.0 is loading!");
            
            var harmony = new Harmony("com.yourusername.peakcoinmod.harmony");
            harmony.PatchAll();
            
            Log.LogInfo("Peak Coin Mod is ready for business!");
        }

        // The OnGUI method has been removed as it is no longer used.
    }
}

---
./CoinUI.cs
---
using TMPro;
using UnityEngine;

namespace CoinMod
{
    public class CoinUI : MonoBehaviour
    {
        public static CoinUI Instance { get; private set; }
        
        private TextMeshProUGUI coinText;
        private int lastDisplayedCoins = -1;

        public void Initialize()
        {
            if (Instance != null)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;

            coinText = gameObject.AddComponent<TextMeshProUGUI>();
            
            // --- THE NEW, IMPROVED STYLING ---
            var templateText = GUIManager.instance.interactNameText;
            if (templateText != null)
            {
                CoinPlugin.Log.LogInfo("Applying UI style from game's interact text.");
                // Copy the essential properties for a perfect match
                coinText.font = templateText.font;
                coinText.fontMaterial = templateText.fontMaterial; // This is the key for outlines/effects
                coinText.fontSize = templateText.fontSize;
                coinText.color = templateText.color; // Use the game's exact text color
                coinText.alignment = TextAlignmentOptions.Left;
                
                // We no longer need to manually set outline properties,
                // as they are inherited from the fontMaterial.
            }
            else
            {
                // Fallback to basic styling if the template isn't found
                CoinPlugin.Log.LogWarning("Could not find UI template, using basic style.");
                coinText.fontSize = 24;
                coinText.color = Color.white;
            }
        }
        
        public void SetCanvasParent(Transform canvasParent)
        {
            transform.SetParent(canvasParent, false);

            RectTransform rect = GetComponent<RectTransform>();
            if (rect == null) rect = gameObject.AddComponent<RectTransform>();
            rect.anchorMin = new Vector2(0, 1);
            rect.anchorMax = new Vector2(0, 1);
            rect.pivot = new Vector2(0, 1);
            rect.anchoredPosition = new Vector2(20, -20);
        }

        private void Update()
        {
            if (PlayerCoinManager.HostInstance == null) return;

            int currentCoins = PlayerCoinManager.HostInstance.SharedCoins;
            if (currentCoins != lastDisplayedCoins)
            {
                UpdateCoinCount(currentCoins);
                lastDisplayedCoins = currentCoins;
            }
        }

        public void UpdateCoinCount(int newAmount)
        {
            if (coinText != null)
            {
                coinText.text = $"Coins: {newAmount}"; 
            }
        }
    }
}

---
./PlayerCoinManager.cs
---
using Photon.Pun;
using UnityEngine;

namespace CoinMod
{
    // This component will be attached to the Player object, which is already networked and persistent.
    public class PlayerCoinManager : MonoBehaviourPun
    {
        // A static reference to the HOST's instance of this component.
        public static PlayerCoinManager HostInstance { get; private set; }

        public int SharedCoins { get; private set; }

        private void Awake()
        {
            // If this component is on the MasterClient's player object, it becomes the authority.
            if (photonView.IsMine && PhotonNetwork.IsMasterClient)
            {
                if (HostInstance != null)
                {
                    CoinPlugin.Log.LogWarning("Multiple HostInstances detected. This shouldn't happen.");
                }
                HostInstance = this;
                CoinPlugin.Log.LogInfo("This player is the host. PlayerCoinManager is now authoritative.");
            }
        }

        // Only the host can call this to change the value.
        // It's not an RPC itself.
        public void ModifyCoinsOnHost(int amount)
        {
            if (!PhotonNetwork.IsMasterClient)
            {
                CoinPlugin.Log.LogError("A client tried to call ModifyCoinsOnHost directly!");
                return;
            }

            int newTotal = SharedCoins + amount;
            if (newTotal < 0) newTotal = 0;

            // Now, the host broadcasts the new total to everyone.
            photonView.RPC(nameof(RPC_Client_UpdateCoins), RpcTarget.All, newTotal);
        }

        [PunRPC]
        private void RPC_Client_UpdateCoins(int newTotal)
        {
            // This runs on everyone's machine to keep the value synchronized.
            SharedCoins = newTotal;
        }
        
        // This is the RPC that clients will call.
        [PunRPC]
        public void RPC_Request_ModifyCoins(int amount)
        {
            if (HostInstance != null)
            {
                // The client's request is forwarded to the host's instance to be processed.
                HostInstance.ModifyCoinsOnHost(amount);
            }
        }
    }
}

---
./README.md
---
# musical-enigma


---
./ShopManager.cs
---
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using Photon.Pun; // Added for TryToBuyItem

namespace CoinMod
{
    // Now a MonoBehaviour, so it can have an Update loop and be a component in the scene.
    public class ShopManager : MonoBehaviour
    {
        // --- Singleton and State ---
        public static ShopManager Instance { get; private set; }
        private bool isShopOpen = false;
        
        // --- Distance Check ---
        private Campfire activeCampfire;
        private const float MaxInteractionDistance = 10f;

        // --- UI References ---
        private GameObject shopPanel;
        private RectTransform contentRect;
        private TextMeshProUGUI coinText;
        private GameObject itemListingPrefab;

        // --- Data ---
        private static List<Item> allItems = new List<Item>();
        private static bool hasInitializedItems = false;
        private static readonly int DefaultPrice = 25;
        private static readonly Dictionary<string, int> ItemPrices = new Dictionary<string, int>
        {
            // --- Tier 1: Trivial & Common (2-5 Coins) ---
            { "Stone", 2 }, { "FireWood", 2 }, { "Marshmallow", 4 }, { "Item_Coconut_half", 4 }, { "Egg", 5 }, { "Frisbee", 3 }, { "Berrynana Peel Blue Variant", 5 }, { "Bugfix", 2 },
            // --- Tier 2: Useful Consumables (6-13 Coins) ---
            { "Flare", 6 }, { "Bandages", 8 }, { "Airplane Food", 9 }, { "Granola Bar", 9 }, { "Sports Drink", 10 }, { "ScoutCookies", 10 }, { "TrailMix", 11 }, { "Heat Pack", 11 }, { "Item_Coconut", 12 }, { "MedicinalRoot", 13 },
            // --- Tier 3: Core Tools & Better Consumables (15-28 Coins) ---
            { "Binoculars", 15 }, { "Parasol", 18 }, { "Compass", 20 }, { "Piton", 20 }, { "RopeSpool", 22 }, { "Lantern", 25 }, { "Energy Drink", 15 }, { "Antidote", 28 }, { "Cure-Some", 25 },
            // --- Tier 4: Powerful & Upgraded Gear (30-60 Coins) ---
            { "FirstAidKit", 30 }, { "EnergyElixir", 32 }, { "RopeShooter", 38 }, { "ChainShooter", 40 }, { "RopeShooterAnti", 42 }, { "PortableStovetopItem", 45 }, { "Backpack", 60 },
            // --- Tier 5: Rare, Magical & Quirky (65+ Coins) ---
            { "Cure-All", 65 }, { "Lantern_Faerie", 70 }, { "Warp Compass", 75 }, { "Pirate Compass", 80 }, { "Bugle_Magic", 88 }, { "MagicBean", 90 }, { "PandorasBox", 125 }, { "Cursed Skull", 100 }, { "ScoutEffigy", 75 },
            // --- All Other Items Priced Logically ---
            { "Anti-Rope Spool", 22 }, { "Beehive", 15 }, { "NestEgg", 20 }, { "Lollipop", 10 }, { "HealingDart Variant", 35 }, { "BounceShroom", 8 }, { "Bugle", 18 }, { "Mushroom Lace", 8 }, { "Mushroom Normie Poison", 5 }, { "CactusBall", 8 }, { "Mushroom Chubby", 6 }, { "Mushroom Cluster Poison", 6 }, { "Shell Big", 15 }, { "Item_Honeycomb", 12 }, { "Megaphone", 12 }, { "HealingPuffShroom", 15 }, { "Pepper Berry", 8 }, { "Bugle_Scoutmaster Variant", 45 }, { "ShelfShroom", 5 }, { "Strange Gem", 50 }, { "Flag_Plantable_Seagull", 10 }, { "Mushroom Glow", 8 }, { "Wonderberry", 12 },
            // Berries
            { "Clusterberry Black", 8 }, { "Clusterberry Red", 8 }, { "Clusterberry Yellow", 8 }, { "Clusterberry_UNUSED", 8 }, { "Apple Berry Green", 6 }, { "Apple Berry Red", 6 }, { "Apple Berry Yellow", 6 }, { "Kingberry Green", 10 }, { "Kingberry Purple", 10 }, { "Kingberry Yellow", 10 }, { "Berrynana Blue", 8 }, { "Berrynana Brown", 8 }, { "Berrynana Pink", 8 }, { "Berrynana Yellow", 8 }, { "Napberry", 9 }, { "Winterberry Orange", 8 }, { "Winterberry Yellow", 8 },
            // Items That Shouldn't Be For Sale (Priced very high)
            { "BingBong", 9999 }, { "Passport", 9999 }, { "Guidebook", 9999 }, { "GuidebookPageScroll Variant", 999 }, { "GuidebookPage_4_BodyHeat Variant", 999 },
        };

        void Awake()
        {
            if (Instance != null)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            
            CreateShopUI();
        }

        void Update()
        {
            if (!isShopOpen || activeCampfire == null || Character.localCharacter == null)
            {
                return;
            }

            float distance = Vector3.Distance(Character.localCharacter.Center, activeCampfire.transform.position);
            if (distance > MaxInteractionDistance)
            {
                CoinPlugin.Log.LogInfo("Player is too far from the campfire. Closing shop.");
                CloseShopGUI();
            }

            if (coinText != null && PlayerCoinManager.HostInstance != null)
            {
                coinText.text = $"Team Coins: {PlayerCoinManager.HostInstance.SharedCoins}";
            }
        }

        public void OpenShopGUI(Campfire campfire)
        {
            if (isShopOpen) return;
            
            activeCampfire = campfire;
            isShopOpen = true;
            shopPanel.SetActive(true);
            
            if (!hasInitializedItems) InitializeItemList();
            PopulateShop();
            
            SetCursorState(true);
        }

        public void CloseShopGUI()
        {
            if (!isShopOpen) return;

            activeCampfire = null;
            isShopOpen = false;
            shopPanel.SetActive(false);
            
            SetCursorState(false);
        }

        // In ShopManager.cs

private void PopulateShop()
{
    // Clear any old item listings
    foreach (Transform child in contentRect)
    {
        Destroy(child.gameObject);
    }
    
    int currentCoins = (PlayerCoinManager.HostInstance != null) ? PlayerCoinManager.HostInstance.SharedCoins : 0;

    // Create a new listing for each item
    foreach (var item in allItems)
    {
        if (!ItemPrices.TryGetValue(item.name, out int price)) price = DefaultPrice;

        GameObject newItemEntry = Instantiate(itemListingPrefab, contentRect);
        newItemEntry.SetActive(true); // Make sure the instantiated object is active
        
        // Find components in the new entry
        Image itemIcon = newItemEntry.transform.Find("ItemIcon").GetComponent<Image>();
        TextMeshProUGUI itemName = newItemEntry.transform.Find("ItemName").GetComponent<TextMeshProUGUI>();
        Button buyButton = newItemEntry.transform.Find("BuyButton").GetComponent<Button>();
        TextMeshProUGUI buyButtonText = buyButton.GetComponentInChildren<TextMeshProUGUI>();

        // --- THIS IS THE CORRECTED LOGIC ---
        if (item.UIData?.icon != null)
        {
            // Convert the item's Texture2D to a Sprite
            Texture2D tex = item.UIData.icon;
            itemIcon.sprite = Sprite.Create(tex, new Rect(0, 0, tex.width, tex.height), new Vector2(0.5f, 0.5f));
        }
        else
        {
            // Use the game's default empty sprite as a fallback
            itemIcon.sprite = GUIManager.instance.emptySprite;
        }
        
        itemName.text = item.UIData?.itemName ?? item.name;
        buyButtonText.text = price < 9000 ? $"Buy ({price})" : "N/A";
        
        bool canAfford = currentCoins >= price && price < 9000;
        buyButton.interactable = canAfford;
        
        // Add a listener to the button to handle the purchase
        buyButton.onClick.AddListener(() => TryToBuyItem(item, price));
    }
}
        
        private static void InitializeItemList()
        {
            var uniqueItems = new Dictionary<string, Item>();
            var foundItems = Resources.FindObjectsOfTypeAll<Item>();
            foreach (var item in foundItems)
            {
                if (item != null && item.gameObject.scene.handle == 0 && !string.IsNullOrEmpty(item.UIData?.itemName))
                {
                    if (!uniqueItems.ContainsKey(item.UIData.itemName))
                    {
                        uniqueItems.Add(item.UIData.itemName, item);
                    }
                }
            }
            allItems = uniqueItems.Values.OrderBy(item => item.UIData.itemName).ToList();
            hasInitializedItems = true;
        }

        private void TryToBuyItem(Item itemPrefab, int price)
        {
            if (PlayerCoinManager.HostInstance == null) return;
            if (PlayerCoinManager.HostInstance.SharedCoins < price) return;

            PlayerCoinManager.HostInstance.photonView.RPC("RPC_Request_ModifyCoins", PlayerCoinManager.HostInstance.photonView.Owner, -price);
            CoinPlugin.Log.LogInfo($"Requested to buy {itemPrefab.UIData.itemName} for {price} coins.");

            if (Character.localCharacter != null)
            {
                Vector3 spawnPos = Character.localCharacter.Center + Character.localCharacter.transform.forward * 1.5f + Vector3.up * 0.5f;
                PhotonNetwork.Instantiate("0_Items/" + itemPrefab.name, spawnPos, Quaternion.identity);
            }
            
            PopulateShop();
        }
        
        private static void SetCursorState(bool uiOpen)
        {
            Cursor.visible = uiOpen;
            Cursor.lockState = uiOpen ? CursorLockMode.None : CursorLockMode.Locked;
        }

        #region UI Creation
        private void CreateShopUI()
        {
            var canvas = GUIManager.instance.hudCanvas.transform;

            shopPanel = new GameObject("ShopPanel");
            shopPanel.transform.SetParent(canvas, false);
            var panelImage = shopPanel.AddComponent<Image>();
            panelImage.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);
            var rt = shopPanel.GetComponent<RectTransform>();
            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = new Vector2(500, 650);

            var titleGo = new GameObject("Title");
            titleGo.transform.SetParent(shopPanel.transform, false);
            var titleText = titleGo.AddComponent<TextMeshProUGUI>();
            titleText.text = "Campfire Shop";
            titleText.fontSize = 32;
            titleText.color = Color.white;
            titleText.alignment = TextAlignmentOptions.Center;
            var titleRt = titleGo.GetComponent<RectTransform>();
            titleRt.anchorMin = new Vector2(0, 1);
            titleRt.anchorMax = new Vector2(1, 1);
            titleRt.pivot = new Vector2(0.5f, 1);
            titleRt.anchoredPosition = new Vector2(0, -20);

            var coinGo = new GameObject("CoinText");
            coinGo.transform.SetParent(shopPanel.transform, false);
            coinText = coinGo.AddComponent<TextMeshProUGUI>();
            coinText.fontSize = 20;
            coinText.color = Color.yellow;
            coinText.alignment = TextAlignmentOptions.Center;
            var coinRt = coinGo.GetComponent<RectTransform>();
            coinRt.anchorMin = new Vector2(0, 1);
            coinRt.anchorMax = new Vector2(1, 1);
            coinRt.pivot = new Vector2(0.5f, 1);
            coinRt.anchoredPosition = new Vector2(0, -60);
            
            var scrollGo = new GameObject("ScrollView");
            scrollGo.transform.SetParent(shopPanel.transform, false);
            var scrollRect = scrollGo.AddComponent<ScrollRect>();
            var scrollImage = scrollGo.AddComponent<Image>();
            scrollImage.color = new Color(0, 0, 0, 0.5f);
            var scrollRt = scrollGo.GetComponent<RectTransform>();
            scrollRt.anchorMin = new Vector2(0, 0);
            scrollRt.anchorMax = new Vector2(1, 1);
            scrollRt.pivot = new Vector2(0.5f, 0.5f);
            scrollRt.anchoredPosition = new Vector2(0, -40);
            scrollRt.sizeDelta = new Vector2(-40, -150);

            var viewportGo = new GameObject("Viewport");
            viewportGo.transform.SetParent(scrollGo.transform, false);
            viewportGo.AddComponent<Mask>().showMaskGraphic = false;
            viewportGo.AddComponent<Image>();
            var viewportRt = viewportGo.GetComponent<RectTransform>();
            viewportRt.anchorMin = Vector2.zero;
            viewportRt.anchorMax = Vector2.one;
            viewportRt.sizeDelta = Vector2.zero;
            viewportRt.pivot = new Vector2(0, 1);

            var contentGo = new GameObject("Content");
            contentRect = contentGo.AddComponent<RectTransform>();
            contentRect.transform.SetParent(viewportGo.transform, false);
            contentRect.anchorMin = new Vector2(0, 1);
            contentRect.anchorMax = new Vector2(1, 1);
            contentRect.pivot = new Vector2(0.5f, 1);
            contentRect.sizeDelta = new Vector2(0, 0);

            var vlg = contentGo.AddComponent<VerticalLayoutGroup>();
            vlg.padding = new RectOffset(10, 10, 10, 10);
            vlg.spacing = 5;
            vlg.childControlHeight = true;
            vlg.childControlWidth = true;
            vlg.childForceExpandHeight = false;
            vlg.childForceExpandWidth = true;

            var csf = contentGo.AddComponent<ContentSizeFitter>();
            csf.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            scrollRect.viewport = viewportRt;
            scrollRect.content = contentRect;
            
            var closeGo = new GameObject("CloseButton");
            closeGo.transform.SetParent(shopPanel.transform, false);
            var closeButton = closeGo.AddComponent<Button>();
            var closeImage = closeGo.AddComponent<Image>();
            closeImage.color = new Color(0.8f, 0.2f, 0.2f);
            var closeRt = closeGo.GetComponent<RectTransform>();
            closeRt.anchorMin = new Vector2(0.5f, 0);
            closeRt.anchorMax = new Vector2(0.5f, 0);
            closeRt.pivot = new Vector2(0.5f, 0);
            closeRt.sizeDelta = new Vector2(150, 40);
            closeRt.anchoredPosition = new Vector2(0, 20);

            var closeTextGo = new GameObject("Text");
            closeTextGo.transform.SetParent(closeGo.transform, false);
            var closeText = closeTextGo.AddComponent<TextMeshProUGUI>();
            closeText.text = "Close";
            closeText.color = Color.white;
            closeText.alignment = TextAlignmentOptions.Center;
            closeText.fontSize = 20;

            closeButton.onClick.AddListener(CloseShopGUI);
            
            CreateItemListingPrefab();
            
            shopPanel.SetActive(false);
        }

        private void CreateItemListingPrefab()
        {
            itemListingPrefab = new GameObject("ItemListingPrefab");
            var itemImage = itemListingPrefab.AddComponent<Image>();
            itemImage.color = new Color(0.2f, 0.2f, 0.2f, 1f);
            itemListingPrefab.AddComponent<LayoutElement>().minHeight = 50;

            var hlg = itemListingPrefab.AddComponent<HorizontalLayoutGroup>();
            hlg.padding = new RectOffset(5, 5, 5, 5);
            hlg.spacing = 10;
            hlg.childAlignment = TextAnchor.MiddleLeft;

            var iconGo = new GameObject("ItemIcon");
            iconGo.transform.SetParent(itemListingPrefab.transform, false);
            iconGo.AddComponent<Image>();
            iconGo.AddComponent<LayoutElement>().preferredWidth = 40;
            
            var nameGo = new GameObject("ItemName");
            nameGo.transform.SetParent(itemListingPrefab.transform, false);
            var nameText = nameGo.AddComponent<TextMeshProUGUI>();
            nameText.color = Color.white;
            nameText.fontSize = 18;
            nameGo.AddComponent<LayoutElement>().flexibleWidth = 1;

            var buttonGo = new GameObject("BuyButton");
            buttonGo.transform.SetParent(itemListingPrefab.transform, false);
            buttonGo.AddComponent<Button>();
            var buttonImage = buttonGo.AddComponent<Image>();
            buttonImage.color = new Color(0.2f, 0.5f, 0.2f);
            var buttonLayout = buttonGo.AddComponent<LayoutElement>();
            buttonLayout.minWidth = 100;
            buttonLayout.preferredWidth = 100;

            var buttonTextGo = new GameObject("Text");
            buttonTextGo.transform.SetParent(buttonGo.transform, false);
            var buttonText = buttonTextGo.AddComponent<TextMeshProUGUI>();
            buttonText.color = Color.white;
            buttonText.fontSize = 16;
            buttonText.alignment = TextAlignmentOptions.Center;
            
            itemListingPrefab.SetActive(false);
        }
        #endregion
    }
}

---
./ShopkeeperBingBong.cs
---
using UnityEngine;

namespace CoinMod
{
    // This is a "marker" component. It has no code.
    // Its only purpose is to be attached to our custom BingBong shopkeepers
    // so we can identify them with GetComponent().
    public class ShopkeeperBingBong : MonoBehaviour { }
}

---
./nuget.config
---
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <!-- This line adds the standard NuGet source, which is good practice -->
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
    <!-- THIS IS THE MAGIC LINE: It adds the BepInEx-specific source -->
    <add key="BepInEx" value="https://nuget.bepinex.dev/v3/index.json" />
  </packageSources>
</configuration>

---
./output.txt
---
./CoinModProject.csproj
---
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <AssemblyName>lansmurf.PeakCoinMod</AssemblyName>
    <Description>Adds a coin and shopkeeper system to PEAK.</Description>
    <Version>1.2.0</Version>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BepInEx.AssemblyPublicizer" Version="0.5.0-beta.1" PrivateAssets="all" />
    <PackageReference Include="BepInEx.BaseLib" Version="5.*" />
    <PackageReference Include="BepInEx.Analyzers" Version="1.*" PrivateAssets="all" />
    <PackageReference Include="BepInEx.PluginInfoProps" Version="1.*" />
    <PackageReference Include="HarmonyX" Version="2.10.2" />
    
    <Reference Include="UnityEngine" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.InputLegacyModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <!-- === REQUIRED UNITY MODULES === -->
    <Reference Include="UnityEngine.PhysicsModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.AnimationModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.AnimationModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.IMGUIModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <!-- THIS IS THE NEW REFERENCE YOU NEED -->
    <Reference Include="UnityEngine.UIModule" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.UIModule.dll</HintPath>
        <Private>false</Private>
    </Reference>

    <Reference Include="UnityEngine.UI" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\UnityEngine.UI.dll</HintPath>
        <Private>false</Private>
    </Reference>

    <Reference Include="Unity.TextMeshPro" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Unity.TextMeshPro.dll</HintPath>
        <Private>false</Private>
    </Reference>
    
    <Reference Include="Sirenix.Serialization" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Sirenix.Serialization.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <!-- === END OF REQUIRED MODULES === -->

    <Reference Include="Assembly-CSharp" Publicize="true">
      <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Assembly-CSharp.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="Zorro.Core.Runtime" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\Zorro.Core.Runtime.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="PhotonUnityNetworking" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\PhotonUnityNetworking.dll</HintPath>
        <Private>false</Private>
    </Reference>
    <Reference Include="PhotonRealtime" Publicize="true">
        <HintPath>C:\Program Files (x86)\Steam\steamapps\common\PEAK\PEAK_Data\Managed\PhotonRealtime.dll</HintPath>
        <Private>false</Private>
    </Reference>
  </ItemGroup>
</Project>

---
./CoinPlugin.cs
---
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;

namespace CoinMod
{
    [BepInPlugin("com.yourusername.peakcoinmod", "Peak Coin Mod", "3.0.0")]
    public class CoinPlugin : BaseUnityPlugin
    {
        internal static ManualLogSource Log;

        private void Awake()
        {
            Log = Logger;
            Log.LogInfo("Peak Coin Mod v3.0.0 is loading!");
            
            var harmony = new Harmony("com.yourusername.peakcoinmod.harmony");
            harmony.PatchAll();
            
            Log.LogInfo("Peak Coin Mod is ready for business!");
        }

        // The OnGUI method has been removed as it is no longer used.
    }
}

---
./CoinUI.cs
---
using TMPro;
using UnityEngine;

namespace CoinMod
{
    public class CoinUI : MonoBehaviour
    {
        public static CoinUI Instance { get; private set; }
        
        private TextMeshProUGUI coinText;
        private int lastDisplayedCoins = -1;

        public void Initialize()
        {
            if (Instance != null)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;

            coinText = gameObject.AddComponent<TextMeshProUGUI>();
            
            // --- THE NEW, IMPROVED STYLING ---
            var templateText = GUIManager.instance.interactNameText;
            if (templateText != null)
            {
                CoinPlugin.Log.LogInfo("Applying UI style from game's interact text.");
                // Copy the essential properties for a perfect match
                coinText.font = templateText.font;
                coinText.fontMaterial = templateText.fontMaterial; // This is the key for outlines/effects
                coinText.fontSize = templateText.fontSize;
                coinText.color = templateText.color; // Use the game's exact text color
                coinText.alignment = TextAlignmentOptions.Left;
                
                // We no longer need to manually set outline properties,
                // as they are inherited from the fontMaterial.
            }
            else
            {
                // Fallback to basic styling if the template isn't found
                CoinPlugin.Log.LogWarning("Could not find UI template, using basic style.");
                coinText.fontSize = 24;
                coinText.color = Color.white;
            }
        }
        
        public void SetCanvasParent(Transform canvasParent)
        {
            transform.SetParent(canvasParent, false);

            RectTransform rect = GetComponent<RectTransform>();
            if (rect == null) rect = gameObject.AddComponent<RectTransform>();
            rect.anchorMin = new Vector2(0, 1);
            rect.anchorMax = new Vector2(0, 1);
            rect.pivot = new Vector2(0, 1);
            rect.anchoredPosition = new Vector2(20, -20);
        }

        private void Update()
        {
            if (PlayerCoinManager.HostInstance == null) return;

            int currentCoins = PlayerCoinManager.HostInstance.SharedCoins;
            if (currentCoins != lastDisplayedCoins)
            {
                UpdateCoinCount(currentCoins);
                lastDisplayedCoins = currentCoins;
            }
        }

        public void UpdateCoinCount(int newAmount)
        {
            if (coinText != null)
            {
                coinText.text = $"Coins: {newAmount}"; 
            }
        }
    }
}

---
./PlayerCoinManager.cs
---
using Photon.Pun;
using UnityEngine;

namespace CoinMod
{
    // This component will be attached to the Player object, which is already networked and persistent.
    public class PlayerCoinManager : MonoBehaviourPun
    {
        // A static reference to the HOST's instance of this component.
        public static PlayerCoinManager HostInstance { get; private set; }

        public int SharedCoins { get; private set; }

        private void Awake()
        {
            // If this component is on the MasterClient's player object, it becomes the authority.
            if (photonView.IsMine && PhotonNetwork.IsMasterClient)
            {
                if (HostInstance != null)
                {
                    CoinPlugin.Log.LogWarning("Multiple HostInstances detected. This shouldn't happen.");
                }
                HostInstance = this;
                CoinPlugin.Log.LogInfo("This player is the host. PlayerCoinManager is now authoritative.");
            }
        }

        // Only the host can call this to change the value.
        // It's not an RPC itself.
        public void ModifyCoinsOnHost(int amount)
        {
            if (!PhotonNetwork.IsMasterClient)
            {
                CoinPlugin.Log.LogError("A client tried to call ModifyCoinsOnHost directly!");
                return;
            }

            int newTotal = SharedCoins + amount;
            if (newTotal < 0) newTotal = 0;

            // Now, the host broadcasts the new total to everyone.
            photonView.RPC(nameof(RPC_Client_UpdateCoins), RpcTarget.All, newTotal);
        }

        [PunRPC]
        private void RPC_Client_UpdateCoins(int newTotal)
        {
            // This runs on everyone's machine to keep the value synchronized.
            SharedCoins = newTotal;
        }
        
        // This is the RPC that clients will call.
        [PunRPC]
        public void RPC_Request_ModifyCoins(int amount)
        {
            if (HostInstance != null)
            {
                // The client's request is forwarded to the host's instance to be processed.
                HostInstance.ModifyCoinsOnHost(amount);
            }
        }
    }
}

---
./README.md
---
# musical-enigma


---
./ShopManager.cs
---
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using Photon.Pun; // Added for TryToBuyItem

namespace CoinMod
{
    // Now a MonoBehaviour, so it can have an Update loop and be a component in the scene.
    public class ShopManager : MonoBehaviour
    {
        // --- Singleton and State ---
        public static ShopManager Instance { get; private set; }
        private bool isShopOpen = false;
        
        // --- Distance Check ---
        private Campfire activeCampfire;
        private const float MaxInteractionDistance = 10f;

        // --- UI References ---
        private GameObject shopPanel;
        private RectTransform contentRect;
        private TextMeshProUGUI coinText;
        private GameObject itemListingPrefab;

        // --- Data ---
        private static List<Item> allItems = new List<Item>();
        private static bool hasInitializedItems = false;
        private static readonly int DefaultPrice = 25;
        private static readonly Dictionary<string, int> ItemPrices = new Dictionary<string, int>
        {
            // --- Tier 1: Trivial & Common (2-5 Coins) ---
            { "Stone", 2 }, { "FireWood", 2 }, { "Marshmallow", 4 }, { "Item_Coconut_half", 4 }, { "Egg", 5 }, { "Frisbee", 3 }, { "Berrynana Peel Blue Variant", 5 }, { "Bugfix", 2 },
            // --- Tier 2: Useful Consumables (6-13 Coins) ---
            { "Flare", 6 }, { "Bandages", 8 }, { "Airplane Food", 9 }, { "Granola Bar", 9 }, { "Sports Drink", 10 }, { "ScoutCookies", 10 }, { "TrailMix", 11 }, { "Heat Pack", 11 }, { "Item_Coconut", 12 }, { "MedicinalRoot", 13 },
            // --- Tier 3: Core Tools & Better Consumables (15-28 Coins) ---
            { "Binoculars", 15 }, { "Parasol", 18 }, { "Compass", 20 }, { "Piton", 20 }, { "RopeSpool", 22 }, { "Lantern", 25 }, { "Energy Drink", 15 }, { "Antidote", 28 }, { "Cure-Some", 25 },
            // --- Tier 4: Powerful & Upgraded Gear (30-60 Coins) ---
            { "FirstAidKit", 30 }, { "EnergyElixir", 32 }, { "RopeShooter", 38 }, { "ChainShooter", 40 }, { "RopeShooterAnti", 42 }, { "PortableStovetopItem", 45 }, { "Backpack", 60 },
            // --- Tier 5: Rare, Magical & Quirky (65+ Coins) ---
            { "Cure-All", 65 }, { "Lantern_Faerie", 70 }, { "Warp Compass", 75 }, { "Pirate Compass", 80 }, { "Bugle_Magic", 88 }, { "MagicBean", 90 }, { "PandorasBox", 125 }, { "Cursed Skull", 100 }, { "ScoutEffigy", 75 },
            // --- All Other Items Priced Logically ---
            { "Anti-Rope Spool", 22 }, { "Beehive", 15 }, { "NestEgg", 20 }, { "Lollipop", 10 }, { "HealingDart Variant", 35 }, { "BounceShroom", 8 }, { "Bugle", 18 }, { "Mushroom Lace", 8 }, { "Mushroom Normie Poison", 5 }, { "CactusBall", 8 }, { "Mushroom Chubby", 6 }, { "Mushroom Cluster Poison", 6 }, { "Shell Big", 15 }, { "Item_Honeycomb", 12 }, { "Megaphone", 12 }, { "HealingPuffShroom", 15 }, { "Pepper Berry", 8 }, { "Bugle_Scoutmaster Variant", 45 }, { "ShelfShroom", 5 }, { "Strange Gem", 50 }, { "Flag_Plantable_Seagull", 10 }, { "Mushroom Glow", 8 }, { "Wonderberry", 12 },
            // Berries
            { "Clusterberry Black", 8 }, { "Clusterberry Red", 8 }, { "Clusterberry Yellow", 8 }, { "Clusterberry_UNUSED", 8 }, { "Apple Berry Green", 6 }, { "Apple Berry Red", 6 }, { "Apple Berry Yellow", 6 }, { "Kingberry Green", 10 }, { "Kingberry Purple", 10 }, { "Kingberry Yellow", 10 }, { "Berrynana Blue", 8 }, { "Berrynana Brown", 8 }, { "Berrynana Pink", 8 }, { "Berrynana Yellow", 8 }, { "Napberry", 9 }, { "Winterberry Orange", 8 }, { "Winterberry Yellow", 8 },
            // Items That Shouldn't Be For Sale (Priced very high)
            { "BingBong", 9999 }, { "Passport", 9999 }, { "Guidebook", 9999 }, { "GuidebookPageScroll Variant", 999 }, { "GuidebookPage_4_BodyHeat Variant", 999 },
        };

        void Awake()
        {
            if (Instance != null)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            
            CreateShopUI();
        }

        void Update()
        {
            if (!isShopOpen || activeCampfire == null || Character.localCharacter == null)
            {
                return;
            }

            float distance = Vector3.Distance(Character.localCharacter.Center, activeCampfire.transform.position);
            if (distance > MaxInteractionDistance)
            {
                CoinPlugin.Log.LogInfo("Player is too far from the campfire. Closing shop.");
                CloseShopGUI();
            }

            if (coinText != null && PlayerCoinManager.HostInstance != null)
            {
                coinText.text = $"Team Coins: {PlayerCoinManager.HostInstance.SharedCoins}";
            }
        }

        public void OpenShopGUI(Campfire campfire)
        {
            if (isShopOpen) return;
            
            activeCampfire = campfire;
            isShopOpen = true;
            shopPanel.SetActive(true);
            
            if (!hasInitializedItems) InitializeItemList();
            PopulateShop();
            
            SetCursorState(true);
        }

        public void CloseShopGUI()
        {
            if (!isShopOpen) return;

            activeCampfire = null;
            isShopOpen = false;
            shopPanel.SetActive(false);
            
            SetCursorState(false);
        }

        // In ShopManager.cs

private void PopulateShop()
{
    // Clear any old item listings
    foreach (Transform child in contentRect)
    {
        Destroy(child.gameObject);
    }
    
    int currentCoins = (PlayerCoinManager.HostInstance != null) ? PlayerCoinManager.HostInstance.SharedCoins : 0;

    // Create a new listing for each item
    foreach (var item in allItems)
    {
        if (!ItemPrices.TryGetValue(item.name, out int price)) price = DefaultPrice;

        GameObject newItemEntry = Instantiate(itemListingPrefab, contentRect);
        newItemEntry.SetActive(true); // Make sure the instantiated object is active
        
        // Find components in the new entry
        Image itemIcon = newItemEntry.transform.Find("ItemIcon").GetComponent<Image>();
        TextMeshProUGUI itemName = newItemEntry.transform.Find("ItemName").GetComponent<TextMeshProUGUI>();
        Button buyButton = newItemEntry.transform.Find("BuyButton").GetComponent<Button>();
        TextMeshProUGUI buyButtonText = buyButton.GetComponentInChildren<TextMeshProUGUI>();

        // --- THIS IS THE CORRECTED LOGIC ---
        if (item.UIData?.icon != null)
        {
            // Convert the item's Texture2D to a Sprite
            Texture2D tex = item.UIData.icon;
            itemIcon.sprite = Sprite.Create(tex, new Rect(0, 0, tex.width, tex.height), new Vector2(0.5f, 0.5f));
        }
        else
        {
            // Use the game's default empty sprite as a fallback
            itemIcon.sprite = GUIManager.instance.emptySprite;
        }
        
        itemName.text = item.UIData?.itemName ?? item.name;
        buyButtonText.text = price < 9000 ? $"Buy ({price})" : "N/A";
        
        bool canAfford = currentCoins >= price && price < 9000;
        buyButton.interactable = canAfford;
        
        // Add a listener to the button to handle the purchase
        buyButton.onClick.AddListener(() => TryToBuyItem(item, price));
    }
}
        
        private static void InitializeItemList()
        {
            var uniqueItems = new Dictionary<string, Item>();
            var foundItems = Resources.FindObjectsOfTypeAll<Item>();
            foreach (var item in foundItems)
            {
                if (item != null && item.gameObject.scene.handle == 0 && !string.IsNullOrEmpty(item.UIData?.itemName))
                {
                    if (!uniqueItems.ContainsKey(item.UIData.itemName))
                    {
                        uniqueItems.Add(item.UIData.itemName, item);
                    }
                }
            }
            allItems = uniqueItems.Values.OrderBy(item => item.UIData.itemName).ToList();
            hasInitializedItems = true;
        }

        private void TryToBuyItem(Item itemPrefab, int price)
        {
            if (PlayerCoinManager.HostInstance == null) return;
            if (PlayerCoinManager.HostInstance.SharedCoins < price) return;

            PlayerCoinManager.HostInstance.photonView.RPC("RPC_Request_ModifyCoins", PlayerCoinManager.HostInstance.photonView.Owner, -price);
            CoinPlugin.Log.LogInfo($"Requested to buy {itemPrefab.UIData.itemName} for {price} coins.");

            if (Character.localCharacter != null)
            {
                Vector3 spawnPos = Character.localCharacter.Center + Character.localCharacter.transform.forward * 1.5f + Vector3.up * 0.5f;
                PhotonNetwork.Instantiate("0_Items/" + itemPrefab.name, spawnPos, Quaternion.identity);
            }
            
            PopulateShop();
        }
        
        private static void SetCursorState(bool uiOpen)
        {
            Cursor.visible = uiOpen;
            Cursor.lockState = uiOpen ? CursorLockMode.None : CursorLockMode.Locked;
        }

        #region UI Creation
        private void CreateShopUI()
        {
            var canvas = GUIManager.instance.hudCanvas.transform;

            shopPanel = new GameObject("ShopPanel");
            shopPanel.transform.SetParent(canvas, false);
            var panelImage = shopPanel.AddComponent<Image>();
            panelImage.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);
            var rt = shopPanel.GetComponent<RectTransform>();
            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = new Vector2(500, 650);

            var titleGo = new GameObject("Title");
            titleGo.transform.SetParent(shopPanel.transform, false);
            var titleText = titleGo.AddComponent<TextMeshProUGUI>();
            titleText.text = "Campfire Shop";
            titleText.fontSize = 32;
            titleText.color = Color.white;
            titleText.alignment = TextAlignmentOptions.Center;
            var titleRt = titleGo.GetComponent<RectTransform>();
            titleRt.anchorMin = new Vector2(0, 1);
            titleRt.anchorMax = new Vector2(1, 1);
            titleRt.pivot = new Vector2(0.5f, 1);
            titleRt.anchoredPosition = new Vector2(0, -20);

            var coinGo = new GameObject("CoinText");
            coinGo.transform.SetParent(shopPanel.transform, false);
            coinText = coinGo.AddComponent<TextMeshProUGUI>();
            coinText.fontSize = 20;
            coinText.color = Color.yellow;
            coinText.alignment = TextAlignmentOptions.Center;
            var coinRt = coinGo.GetComponent<RectTransform>();
            coinRt.anchorMin = new Vector2(0, 1);
            coinRt.anchorMax = new Vector2(1, 1);
            coinRt.pivot = new Vector2(0.5f, 1);
            coinRt.anchoredPosition = new Vector2(0, -60);
            
            var scrollGo = new GameObject("ScrollView");
            scrollGo.transform.SetParent(shopPanel.transform, false);
            var scrollRect = scrollGo.AddComponent<ScrollRect>();
            var scrollImage = scrollGo.AddComponent<Image>();
            scrollImage.color = new Color(0, 0, 0, 0.5f);
            var scrollRt = scrollGo.GetComponent<RectTransform>();
            scrollRt.anchorMin = new Vector2(0, 0);
            scrollRt.anchorMax = new Vector2(1, 1);
            scrollRt.pivot = new Vector2(0.5f, 0.5f);
            scrollRt.anchoredPosition = new Vector2(0, -40);
            scrollRt.sizeDelta = new Vector2(-40, -150);

            var viewportGo = new GameObject("Viewport");
            viewportGo.transform.SetParent(scrollGo.transform, false);
            viewportGo.AddComponent<Mask>().showMaskGraphic = false;
            viewportGo.AddComponent<Image>();
            var viewportRt = viewportGo.GetComponent<RectTransform>();
            viewportRt.anchorMin = Vector2.zero;
            viewportRt.anchorMax = Vector2.one;
            viewportRt.sizeDelta = Vector2.zero;
            viewportRt.pivot = new Vector2(0, 1);

            var contentGo = new GameObject("Content");
            contentRect = contentGo.AddComponent<RectTransform>();
            contentRect.transform.SetParent(viewportGo.transform, false);
            contentRect.anchorMin = new Vector2(0, 1);
            contentRect.anchorMax = new Vector2(1, 1);
            contentRect.pivot = new Vector2(0.5f, 1);
            contentRect.sizeDelta = new Vector2(0, 0);

            var vlg = contentGo.AddComponent<VerticalLayoutGroup>();
            vlg.padding = new RectOffset(10, 10, 10, 10);
            vlg.spacing = 5;
            vlg.childControlHeight = true;
            vlg.childControlWidth = true;
            vlg.childForceExpandHeight = false;
            vlg.childForceExpandWidth = true;

            var csf = contentGo.AddComponent<ContentSizeFitter>();
            csf.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            scrollRect.viewport = viewportRt;
            scrollRect.content = contentRect;
            
            var closeGo = new GameObject("CloseButton");
            closeGo.transform.SetParent(shopPanel.transform, false);
            var closeButton = closeGo.AddComponent<Button>();
            var closeImage = closeGo.AddComponent<Image>();
            closeImage.color = new Color(0.8f, 0.2f, 0.2f);
            var closeRt = closeGo.GetComponent<RectTransform>();
            closeRt.anchorMin = new Vector2(0.5f, 0);
            closeRt.anchorMax = new Vector2(0.5f, 0);
            closeRt.pivot = new Vector2(0.5f, 0);
            closeRt.sizeDelta = new Vector2(150, 40);
            closeRt.anchoredPosition = new Vector2(0, 20);

            var closeTextGo = new GameObject("Text");
            closeTextGo.transform.SetParent(closeGo.transform, false);
            var closeText = closeTextGo.AddComponent<TextMeshProUGUI>();
            closeText.text = "Close";
            closeText.color = Color.white;
            closeText.alignment = TextAlignmentOptions.Center;
            closeText.fontSize = 20;

            closeButton.onClick.AddListener(CloseShopGUI);
            
            CreateItemListingPrefab();
            
            shopPanel.SetActive(false);
        }

        private void CreateItemListingPrefab()
        {
            itemListingPrefab = new GameObject("ItemListingPrefab");
            var itemImage = itemListingPrefab.AddComponent<Image>();
            itemImage.color = new Color(0.2f, 0.2f, 0.2f, 1f);
            itemListingPrefab.AddComponent<LayoutElement>().minHeight = 50;

            var hlg = itemListingPrefab.AddComponent<HorizontalLayoutGroup>();
            hlg.padding = new RectOffset(5, 5, 5, 5);
            hlg.spacing = 10;
            hlg.childAlignment = TextAnchor.MiddleLeft;

            var iconGo = new GameObject("ItemIcon");
            iconGo.transform.SetParent(itemListingPrefab.transform, false);
            iconGo.AddComponent<Image>();
            iconGo.AddComponent<LayoutElement>().preferredWidth = 40;
            
            var nameGo = new GameObject("ItemName");
            nameGo.transform.SetParent(itemListingPrefab.transform, false);
            var nameText = nameGo.AddComponent<TextMeshProUGUI>();
            nameText.color = Color.white;
            nameText.fontSize = 18;
            nameGo.AddComponent<LayoutElement>().flexibleWidth = 1;

            var buttonGo = new GameObject("BuyButton");
            buttonGo.transform.SetParent(itemListingPrefab.transform, false);
            buttonGo.AddComponent<Button>();
            var buttonImage = buttonGo.AddComponent<Image>();
            buttonImage.color = new Color(0.2f, 0.5f, 0.2f);
            var buttonLayout = buttonGo.AddComponent<LayoutElement>();
            buttonLayout.minWidth = 100;
            buttonLayout.preferredWidth = 100;

            var buttonTextGo = new GameObject("Text");
            buttonTextGo.transform.SetParent(buttonGo.transform, false);
            var buttonText = buttonTextGo.AddComponent<TextMeshProUGUI>();
            buttonText.color = Color.white;
            buttonText.fontSize = 16;
            buttonText.alignment = TextAlignmentOptions.Center;
            
            itemListingPrefab.SetActive(false);
        }
        #endregion
    }
}

---
./Patches/CampfirePatches.cs
---
using HarmonyLib;
using UnityEngine;

namespace CoinMod.Patches
{
    [HarmonyPatch(typeof(Campfire))]
    public static class CampfirePatches
    {
        [HarmonyPatch("IsInteractible")]
        [HarmonyPostfix]
        public static void AllowEmptyHandedInteraction(Campfire __instance, Character interactor, ref bool __result)
        {
            if (__result) return;
            if (__instance.Lit && interactor?.data.currentItem == null)
            {
                __result = true;
            }
        }

        [HarmonyPatch("IsConstantlyInteractable")]
        [HarmonyPostfix]
        public static void AllowEmptyHandedConstantInteraction(Campfire __instance, Character interactor, ref bool __result)
        {
            if (__result) return;
            if (__instance.Lit && interactor?.data.currentItem == null)
            {
                __result = true;
            }
        }

        [HarmonyPatch("GetInteractionText")]
        [HarmonyPostfix]
        public static void OverwriteInteractionText(Campfire __instance, ref string __result)
        {
            if (!__instance.Lit) return;
            Character localPlayer = Character.localCharacter;
            if (localPlayer == null) return;

            if (localPlayer.data.currentItem == null)
            {
                __result = "Shop";
            }
        }

        [HarmonyPatch("Interact")]
        [HarmonyPrefix]
        public static bool HandleShopInteraction(Campfire __instance, Character interactor)
        {
            if (__instance.Lit && interactor.data.currentItem == null)
            {
                // Call the new instance method, passing the campfire itself.
                if (ShopManager.Instance != null)
                {
                    ShopManager.Instance.OpenShopGUI(__instance);
                }
                
                return false; 
            }
            return true;
        }
    }
}

---
./Patches/LuggagePatches.cs
---
using HarmonyLib;
using UnityEngine;

namespace CoinMod.Patches
{
    [HarmonyPatch(typeof(Luggage))]
    public static class LuggagePatches
    {
        [HarmonyPatch("Interact_CastFinished")]
        [HarmonyPostfix]
        public static void GiveCoinsOnOpenPatch(Character interactor)
        {
            if (interactor != null && interactor.IsLocal)
            {
                // Find the host's coin manager instance.
                if (PlayerCoinManager.HostInstance != null)
                {
                    int coinsToGive = Random.Range(10, 51);
                    // Call the RPC on the host's instance to request a change.
                    PlayerCoinManager.HostInstance.photonView.RPC("RPC_Request_ModifyCoins", PlayerCoinManager.HostInstance.photonView.Owner, coinsToGive);
                    CoinPlugin.Log.LogInfo($"You opened luggage and requested {coinsToGive} coins for the team!");
                }
            }
        }
    }
}

---
./Patches/PlayerPatch.cs
---
using HarmonyLib;
using UnityEngine;

namespace CoinMod.Patches
{
    [HarmonyPatch(typeof(Player))]
    public static class Player_Patch
    {
        private static bool hasInitializedSystems = false;

        [HarmonyPatch("Awake")]
        [HarmonyPostfix]
        public static void OnPlayerAwake(Player __instance)
        {
            // The Player object is persistent, so we add our manager here.
            if (__instance.gameObject.GetComponent<PlayerCoinManager>() == null)
            {
                __instance.gameObject.AddComponent<PlayerCoinManager>();
            }
            
            // This setup only needs to run ONCE for the local player's entire game session.
            if (__instance.photonView.IsMine && !hasInitializedSystems)
            {
                CoinPlugin.Log.LogInfo("Local player awakened for the first time. Initializing mod systems...");
                
                // --- Create a single, persistent host object for our UI managers ---
                GameObject modHostObject = new GameObject("PeakCoinMod_Systems");
                Object.DontDestroyOnLoad(modHostObject);

                // Add all our MonoBehaviour managers to this one host object.
                // The managers will now control their own lifecycle.
                modHostObject.AddComponent<ShopManager>();
                
                if (CoinUI.Instance == null)
                {
                   var coinUI = modHostObject.AddComponent<CoinUI>();
                   coinUI.Initialize();
                   coinUI.SetCanvasParent(GUIManager.instance.hudCanvas.transform);
                }

                hasInitializedSystems = true;
            }
        }
    }
}

---
./Patches/ShopkeeperPatches.cs
---
using HarmonyLib;

namespace CoinMod.Patches
{
    [HarmonyPatch(typeof(Item))]
    public static class ShopkeeperPatches
    {
        // This patch changes the "Pick up" text to "Shop"
        [HarmonyPatch("GetInteractionText")]
        [HarmonyPrefix]
        public static bool GetInteractionText_Prefix(Item __instance, ref string __result)
        {
            if (__instance.GetComponent<ShopkeeperBingBong>() != null)
            {
                __result = "Shop"; 
                return false;
            }
            return true;
        }

        // --- THIS METHOD IS NOW DISABLED ---
        // Since the shop now requires a campfire for distance checking,
        // this standalone shopkeeper can no longer open the UI correctly.
        /*
        [HarmonyPatch("Interact")]
        [HarmonyPrefix]
        public static bool Interact_Prefix(Item __instance, Character interactor)
        {
            if (__instance.GetComponent<ShopkeeperBingBong>() != null)
            {
                // This line causes the error because we don't have a campfire reference.
                // ShopManager.Instance.OpenShopGUI(); 
                return false;
            }
            return true;
        }
        */
    }
}

---
